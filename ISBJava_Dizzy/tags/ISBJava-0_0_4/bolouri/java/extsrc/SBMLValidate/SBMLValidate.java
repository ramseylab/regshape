/*
** Filename    : SBMLValidate.java
** Description : application class for the SBML validator/NOM module + top level of NOMService implementation
** Author(s)   : SBW Development Group <sysbio-team@caltech.edu>
** Organization: Caltech ERATO Kitano Systems Biology Project
** Created     : 2001-07-07
** Revision    : $Id$
** $Source$
**
** Copyright 2001 California Institute of Technology and
** Japan Science and Technology Corporation.
**
** This library is free software; you can redistribute it and/or modify it
** under the terms of the GNU Lesser General Public License as published
** by the Free Software Foundation; either version 2.1 of the License, or
** any later version.
**
** This library is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
** MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
** documentation provided hereunder is on an "as is" basis, and the
** California Institute of Technology and Japan Science and Technology
** Corporation have no obligations to provide maintenance, support,
** updates, enhancements or modifications.  In no event shall the
** California Institute of Technology or the Japan Science and Technology
** Corporation be liable to any party for direct, indirect, special,
** incidental or consequential damages, including lost profits, arising
** out of the use of this software and its documentation, even if the
** California Institute of Technology and/or Japan Science and Technology
** Corporation have been advised of the possibility of such damage.  See
** the GNU Lesser General Public License for more details.
**
** You should have received a copy of the GNU Lesser General Public License
** along with this library; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
**
** The original code contained here was initially developed by:
**
**     Andrew Finney, Herbert Sauro, Michael Hucka, Hamid Bolouri
**     The Systems Biology Workbench Development Group
**     ERATO Kitano Systems Biology Project
**     Control and Dynamical Systems, MC 107-81
**     California Institute of Technology
**     Pasadena, CA, 91125, USA
**
**     http://www.cds.caltech.edu/erato
**     mailto:sysbio-team@caltech.edu
**
** Contributor(s):
**
** Modified by Stephen Ramsey to remove dependence on Xerxes library, 
** 2003/08/28
*/
package SBMLValidate;

import java.io.*;
import java.lang.String.*;
import javax.swing.*;
import java.net.*;

import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.*;

import edu.caltech.sbw.*;

import uConstants.*;
import uUtils.*;
import uJNetwork.*;
import uSpecies.*;
import uSpeciesList.*;
import uIntObject.*;
import uParameter.*;
import uParameterList.*;
import uReaction.*;
import uReactant.*;
import uOutputNetwork.*;

// TJXML is a XML decorator class for the NOM object class
// The NOM object class defines the interface to an internal representation
// of cellular models. The XML decorator class adds SBML import/export
// functionality to the NOM object

class TJXML implements ErrorHandler {

    // Depending on which constructor is called, the network variable
    // can either be owned by a TJXML instance or passed to it from
    // an outside source.

    // Network object, if the Network object is managed by an external source
    // then this variable is a reference to an external instance
    TJNetwork Network;

    // This is the constructor which results in TJXML managing its own Network object
    TJXML() {
      Network = new TJNetwork();
    }

    /**
     * error string generated by parser
     */
    private String error ;

    // ------------------------------------------------------------------------
    // Get an attribute with name 'AttrName' from a given node. The argument
    // DefaultStr provide a default result if 'AttrName' cannot be found.
    // ------------------------------------------------------------------------

    String GetAttribute (Node node, String AttrName, String DefaultStr) {
         String result = DefaultStr;
         NamedNodeMap Attr = node.getAttributes();
         if (Attr != null) {
            Node AttrNode = Attr.getNamedItem (AttrName);
            if (AttrNode != null)
               result = AttrNode.getNodeValue();
         }
         return result;
    }

    // ------------------------------------------------------------------------
    // Returns a DOMParser. The reason for doing this is because the means by
    // which Parsers are created is not specifed in the W3C docs and each DOM
    // implementation has it's own approach. If we switch to a different DOM
    // library, in theory we need only change this bit.
    // ------------------------------------------------------------------------
    DocumentBuilder GetXMLParser() throws FactoryConfigurationError, ParserConfigurationException {
        DocumentBuilder result = DocumentBuilderFactory.newInstance().newDocumentBuilder();
//         File classFile = Sys.getFileLoadedForClass(SBMLValidate.class);

//         result.setFeature( "http://xml.org/sax/features/validation",
//                            true );
//         result.setFeature( "http://xml.org/sax/features/namespaces",
//                            true );
//         result.setFeature( "http://apache.org/xml/features/validation/schema",
//                            true );
//         result.setFeature( "http://apache.org/xml/features/validation/schema-full-checking",
//                            true );

//         // Fix for bug #713619.
//         // Ugly hack.  Because we mustn't have spaces in the URL for the
//         // schema file here, and because Windows users want to install SBW
//         // into "\Program Files\something" (which does have spaces), I see
//         // no alternative but to put the schema file into someplace
//         // guaranteed not to have spaces in the name.  That only seems to
//         // be the Windows system directory.  The nasty part here is that
//         // we can't really be sure that the pathname doesn't have spaces
//         // on non-Windows systems.  This needs to be revisited in the future.

//         String pathToSchema;
//         if (Sys.OSIsWindows())
//             pathToSchema = Sys.getWindowsSystemDirectory()
//                 + File.separator + "sbml.xsd";
//         else
//             pathToSchema = classFile.getParentFile().toURL().toString()
//                 + "sbml.xsd";

//         result.setProperty(
//             "http://apache.org/xml/properties/schema/external-schemaLocation",
//             "http://www.sbml.org/sbml/level1 " + pathToSchema);

         error = "";
         result.setErrorHandler(this);

        return result;
    }

    // -------------------------
    // XML-Scheme error handlers
    // -------------------------

    // Warning
    public void warning(SAXParseException ex) {
        System.err.println("[Warning] "+
                           getLocationString(ex)+": "+
                           ex.getMessage());
    }

    // Error
    public void error(SAXParseException ex)
    {
        String errorMsg = "[Error] "+ getLocationString(ex)+": "+ ex.getMessage() + '\n';

        error += errorMsg ;
    }

    // Fatal error
    public void fatalError(SAXParseException ex)
    {
        String errorMsg = "[Error] "+ getLocationString(ex)+": "+ ex.getMessage() + '\n';

        error += errorMsg ;
    }

    // Returns a string of the location
    private String getLocationString(SAXParseException ex) {
        StringBuffer str = new StringBuffer();

        String systemId = ex.getSystemId();
        if (systemId != null) {
            int index = systemId.lastIndexOf('/');
            if (index != -1)
                systemId = systemId.substring(index + 1);
            str.append(systemId);
        }
        str.append(':');
        str.append(ex.getLineNumber());
        str.append(':');
        str.append(ex.getColumnNumber());

        return str.toString();
    }


    // ------------------------------------------------------------------------
    // Returns Fixed or Float according to the species type in Node
    // ------------------------------------------------------------------------

    int GetSpeciesType (Node node) {
       int result = TConstants.jmsFloat; // Default
       NamedNodeMap Attr = node.getAttributes();
       if (Attr != null) {
          Node AttrNode = Attr.getNamedItem("boundaryCondition");
          if (AttrNode != null) {
             String xx = AttrNode.getNodeValue();
             if (AttrNode.getNodeValue().toUpperCase().equals ("FALSE"))
                result = TConstants.jmsFloat;
             else result = TConstants.jmsFixed;
          }
       }
       return result;
    }

    // ------------------------------------------------------------------------
    // Reads in the global parameter list. The names of the parameters and their
    // values are stored in the ParameterList argument.
    // ------------------------------------------------------------------------

    void GetGlobalParameterList (TParameterList ParameterList, NodeList nodelist) {
         Node node; String Name; String ValueStr; double Value = 0;
         for (int i = 0; i<nodelist.getLength(); i++) {
             node = nodelist.item(i);
             if (node.getNodeType() != node.TEXT_NODE) {
                Name = GetAttribute (node, "name", "");

                int defined ;
                ValueStr = GetAttribute (nodelist.item(i), "value", "");

                if (ValueStr.length() == 0)
                    defined = TConstants.nsUnDefined ;
                else
                {
                    Value = TUtils.StrToFloat(ValueStr);
                    defined = TConstants.nsDefined;
                }

                ParameterList.add (new TParameter(Name, Value, defined));
             }
         }
    }

    // ------------------------------------------------------------------------
    // Retrieves the stoichiometry from node. This is not complete, it doesn't
    // deal with the possible denomiator part of a stoichiometric spec. Should
    // be easy to put in though
    // ------------------------------------------------------------------------

    int GetStoichiometry (Node node) {
        int result = 1;
        NamedNodeMap Attr = node.getAttributes();
        if (Attr != null) {
           Node AttrNode = Attr.getNamedItem("stoichiometry");
           if (AttrNode != null) {
              String S = AttrNode.getNodeValue();
              int p = S.indexOf ("/");
              if (p == -1)
                 result = TUtils.StrToInt (S);
              // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
              // Needs to account for denominator stoichiometry value !!!!!
              //else result = TUtils.StrToInt (
           }
        }
      return result;
    }

    // ------------------------------------------------------------------------
    // Retrieves the list of reactants and stores them in JReaction
    // ------------------------------------------------------------------------

    void GetReactants (TJNetwork Network, TReaction JReaction, NodeList nodelist) {
         Node node; TSpecies Species;
         for (int i = 0; i<nodelist.getLength(); i++) {
             node = nodelist.item(i);
             if (node.getNodeType() != node.TEXT_NODE) {
                String Name = GetAttribute (node, "specie", "");
                int stoich = GetStoichiometry (node);
                Species = Network.FindMetabolite (Name);
                if (Species != null) {
                   TReactant JReactant = new TReactant();
                   JReactant.Species = Species;
                   JReactant.Stoichiometry = stoich;
                   JReaction.ReactantList.add (JReactant);
                }
             }

         }
    }

    // ------------------------------------------------------------------------
    // Retrieves the list of products and stores them in JReaction
    // ------------------------------------------------------------------------

    void GetProducts (TJNetwork Network, TReaction JReaction, NodeList nodelist) {
         Node node; TSpecies Species;
         for (int i = 0; i<nodelist.getLength(); i++) {
             node = nodelist.item(i);
             if (node.getNodeType() != node.TEXT_NODE) {
                String Name = GetAttribute (node, "specie", "");
                int stoich = GetStoichiometry (node);
                Species = Network.FindMetabolite (Name);
                if (Species != null) {
                   TReactant JReactant = new TReactant();
                   JReactant.Species = Species;
                   JReactant.Stoichiometry = stoich;
                   JReaction.ProductList.add (JReactant);
                }
             }
         }
    }

    // ------------------------------------------------------------------------
    // Gets the rate law formula attribute and stores it in JReaction
    // Also looks for any local parameters and stores them away to.
    // ------------------------------------------------------------------------

    void GetRateLaw (TReaction JReaction, Node node) {
         JReaction.RateLaw.expression = GetAttribute (node, "formula", "");
         NodeList ElementList = node.getChildNodes();
         int length = ElementList.getLength();

         String name;
         for (int i=0; i<length; i++) {
             Node inode = ElementList.item(i);
             if (inode.getNodeType() != inode.TEXT_NODE) {
                 name = inode.getNodeName();
                 if (name.equals("listOfParameters")) {
                    GetParameters (JReaction, inode.getChildNodes());
                    break;
                 }
             }
         }
    }

    // ------------------------------------------------------------------------
    // Stores any local parameters associated with the current rate law
    // ------------------------------------------------------------------------

    void GetParameters (TReaction JReaction, NodeList nodelist) {
          Node node; String name; double value = 0; TParameterList plist;
          for (int i = 0; i<nodelist.getLength(); i++) {
               node = nodelist.item(i);
               if (node.getNodeType() != node.TEXT_NODE) {
                  name = GetAttribute (node, "name", "");

                  int defined ;
                  String valueStr = GetAttribute (node, "value", "");

                  if (valueStr.length() == 0)
                      defined = TConstants.nsUnDefined;
                  else
                  {
                      defined = TConstants.nsDefined;
                      value = TUtils.StrToFloat(valueStr);
                  }

                  plist = JReaction.RateLaw.ParameterList;
                  plist.add (new TParameter(name, value, defined));
               }
          }
    }



    // ------------------------------------------------------------------------
    // Given a Document (a pre-loaded XML script), inspect the DOM tree and
    // copy the model into the NOM object
    // ------------------------------------------------------------------------

    void BuildNetworkModel (Document doc) throws Exception {
        Node node;

        // Read in the comnpartment information

        Network.Name = GetAttribute (doc.getElementsByTagName("model").item(0), "name", "untitled");
        if (doc.getElementsByTagName("listOfCompartments").item(0) != null) {
           NodeList nodeList = doc.getElementsByTagName("listOfCompartments").item(0).getChildNodes();
           for (int i=0; i<nodeList.getLength(); i++) {
               node = nodeList.item (i);
               if (node.getNodeType() != node.TEXT_NODE) {
                  if (!node.getNodeName().equals("compartment"))
                     throw new Exception ("Syntax error: expecting 'compartment' tag in list of compartments");

                  String Name = GetAttribute (node, "name", "");
                  String VolumeStr = GetAttribute (node, "volume", "1.0");
                  if (Name.length() != 0)
                      Network.VolumeList.add (Name, TUtils.StrToFloat (VolumeStr));
              }
           }
        }

        // Read in the species information

        if (doc.getElementsByTagName ("listOfSpecies") != null) {
            NodeList nodelist = doc.getElementsByTagName ("listOfSpecies").item(0).getChildNodes();
            for (int i=0; i<nodelist.getLength(); i++) {
                node = nodelist.item(i);
                if (node.getNodeType() != node.TEXT_NODE) {
                   if (!node.getNodeName().equals("specie"))
                      throw new Exception ("Syntax error: expecting 'specie' tag in list of species");

                   int defined ;
                   String valueStr = GetAttribute (node, "initialAmount", "");
                   double value = 0;

                   if (valueStr.length() == 0)
                       defined = TConstants.nsUnDefined;
                   else
                   {
                        value = TUtils.StrToFloat(valueStr);
                        defined = TConstants.nsDefined ;
                   }

                   String VolumeStr = GetAttribute (node, "compartment", "");
                   String name = GetAttribute (node, "name", "");

                   if (GetSpeciesType (node) == TConstants.jmsFloat) {
                      int SIndex = Network.MetaboliteList.add (name, TConstants.jmsFloat, defined, value);

                      // If the species has a volume element then find the volume object
                      // and associate it with the species

                      // Create an integer object so that we can return integer
                      // values from a method argument list
                      IntObj VolIndex = new IntObj();

                      if (VolumeStr != "") {
                         if (Network.VolumeList.find (VolumeStr, VolIndex)) {
                            Network.MetaboliteList.get(SIndex).Volume = Network.VolumeList.get (VolIndex.i);
                         } else {
                            throw new SBWApplicationException(VolumeStr + "is not a declared volume on species " + name, "");
                         }
                      }
                   } else {
                      int SIndex = Network.BoundaryList.add (name, TConstants.jmsFixed, defined, value);

                      IntObj VolIndex = new IntObj();

                      if (VolumeStr != "") {
                         if (Network.VolumeList.find (VolumeStr, VolIndex)) {
                            Network.BoundaryList.get(SIndex).Volume = Network.VolumeList.get (VolIndex.i);
                         } else {
                            throw new SBWApplicationException(VolumeStr + "is not a declared volume on species " + name, "");
                         }
                      }
                  }
              }
            }  // End of listOfSpecies

          // Read in the global parameters

          node = doc.getElementsByTagName ("listOfParameters").item(0);
          if (node != null && node.getParentNode().getNodeName().equals("model"))
             GetGlobalParameterList (Network.GlobalParameterList, node.getChildNodes());

          // Read in the reaction specifications

          if (doc.getElementsByTagName("listOfReactions") != null) {
              // Get the list of reactions
              nodelist = doc.getElementsByTagName("listOfReactions").item(0).getChildNodes();
              int length = nodelist.getLength();  // A bit of optimization
              for (int i = 0; i<length; i++) {
                  // Get a single reaction
                  node = nodelist.item(i);

                  // Ignore any nodes that are text nodes
                  if (node.getNodeType() != node.TEXT_NODE) {

                      if (!node.getNodeName().equals("reaction"))
                         throw new Exception ("Syntax error: expecting 'reaction' tag in list of reactions");

                     // First get hold of the reaction name and reversibility flag
                     TReaction JReaction = new TReaction(GetAttribute (node, "name", "_J" + TUtils.IntToStr (i)));
                     if (GetAttribute (node, "reversible", "true").equals("true"))
                        JReaction.Reversible = true;
                     else JReaction.Reversible = false;

                     // Get the list containing the reactants, products and kinetic law
                     NodeList ElementList = node.getChildNodes();

                     for (int j = 0; j<ElementList.getLength(); j++) {
                         node = ElementList.item(j);
                         // Ignore text nodes
                         if (node.getNodeType() != node.TEXT_NODE) {
                            String name = node.getNodeName();
                            if (name.equals("listOfReactants"))
                               GetReactants (Network, JReaction, ElementList.item(j).getChildNodes());
                            if (name.equals("listOfProducts"))
                               GetProducts (Network, JReaction, ElementList.item(j).getChildNodes());
                            if (name.equals("kineticLaw")) {
                               GetRateLaw (JReaction, ElementList.item(j));
                            }
                         }
                     } // end for loop
                     // Finally add the reaction object to the reaction list
                     Network.ReactionList.add (JReaction);
                  }
              }
          }
        }
    }

    // ------------------------------------------------------------------------
    // Load some XML from a given file
    // ------------------------------------------------------------------------

    public void LoadFromFile(String XMLFile) throws SBWException
    {
        try
        {
            DocumentBuilder parser = GetXMLParser();
            Document document = parser.parse(XMLFile);
            postParseProcessing(document);
        }
        catch (Throwable t)
        {
            throw SBWException.translateException(t);
        }
    }

    private void postParseProcessing(Document pDocument) throws Throwable
    {
        if (error.length() != 0)
            throw new SBWApplicationException("Error parsing SBML", error);

        BuildNetworkModel (pDocument);
    }

    // ------------------------------------------------------------------------
    // Load some XML from a given string
    // ------------------------------------------------------------------------

    public void LoadFromString (String XMLStr) throws SBWException
    {
        try {
            DocumentBuilder parser = GetXMLParser();
            InputSource is = new InputSource();

            is.setCharacterStream (new StringReader (XMLStr));
            Document document = parser.parse(is);

            postParseProcessing(document);
        }
        catch (Throwable e) {
            throw SBWException.translateException(e);
        }
    }
}


// ------------------------------------------------------------------------
// Main entry point
// ------------------------------------------------------------------------

public class SBMLValidate {
  private static void sbwProcessing(boolean register, boolean unique)
  {
      try
      {
          ModuleImpl moduleImpl;

          if (unique)
          {
              moduleImpl =
                  new ModuleImpl(
                      "edu.caltech.NOMClipboard", "Clipboard Network Object Model",
                      ModuleImpl.UNIQUE, SBMLValidate.class,
                      "This module acts as a clipboard for storing SBML"
                      + " model definitions.  After loading a model into the"
                      + " clipboard from one module, you can read it out again"
                      + " in another module.");

              moduleImpl.setCommandLine(moduleImpl.getCommandLine() + " -unique");

              NOMService service = new NOMService() ;

              moduleImpl.addService(
                  "NOMClipboard", "Save to Network Object Model Clipboard",
                  "Analysis", new NOMAnalysis(service),
                  "Service to allow saving an SBML model into the clipboard");

              moduleImpl.addService(
                  "NOM", "Network Object Model", "", service,
                  "Provides a method for parsing an SBML model into an"
                  + " internal representation (a Network Object Model), as"
                  + " well as methods for accessing the different parts of"
                  + " that model definition through an API.");
          }
          else
          {
              moduleImpl =
                  new ModuleImpl(
                      "edu.caltech.NOM", "Network Object Model",
                      ModuleImpl.SELF_MANAGED, SBMLValidate.class,
                      "Provides facilities for parsing an SBML model"
                      + " definition into an internal form (a Network"
                      + " Object Model) and for reading out the parts of"
                      + " the definition programmatically.");

              moduleImpl.addService(
                  "NOM", "Network Object Model", "", NOMService.class,
                  "Provides a method for parsing an SBML model into an"
                  + " internal representation (a Network Object Model), as"
                  + " well as methods for accessing the different parts of"
                  + " that model definition through an API.");
          }

          if (register)
          {
              moduleImpl.registerModule();
              System.exit(0);
          }
          else
              moduleImpl.enableModuleServices();
      }
      catch (SBWException e)
      {
          e.handleWithDialog();
      }
  }

  /* Main method */
  public static void main(String[] args) {
     if (args.length == 0) {
        System.out.println("Usage, one of either:");
        System.out.println("java SBMLValidator [-dump] xmlfile");
        System.out.println("    -dump   write out summary of model");
        System.out.println("java SBMLValidator -sbwmodule [-unique]");
        System.out.println("java SBMLValidator -sbwregister [-unique]");
        System.out.println("    -unique register/run as a unique module");
        System.exit (0);
     }
     System.out.println ("SBML Validator v0.2");
     TJXML Parser = new TJXML();

     boolean register = false;
     boolean doSbwProcessing = false ;
     boolean dumpOpt = false;
     boolean unique = false ;
     String fileName = "";

     for (int i=0; i<args.length; i++)
     {
         if (args[i].charAt(0) == '-') {
            String opt = args[i].substring(1, args[i].length());
            if (opt.equals("dump")) dumpOpt = true;
            if (opt.equals("sbwregister"))
            {
                register = true;
                doSbwProcessing = true ;
            }
            if (opt.equals("sbwmodule"))
                doSbwProcessing = true ;
            if (opt.equals("unique"))
                unique = true ;
         } else
           fileName = args[i];
     }

     if (doSbwProcessing)
         sbwProcessing(register, unique);
     else
     {
         try {
           Parser.LoadFromFile(fileName);
           System.out.println("SBML validation complete\n");
        } catch (SBWException e) {
           System.out.println ("[Validation failed] " + e.getMessage() + '\n' + e.getDetailedMessage());
           //e.printStackTrace();
        }

        if (dumpOpt) {
            System.out.println("Processed file: " + fileName);
            TOutputNetwork on = new TOutputNetwork (Parser.Network);
            on.OutputNetwork ();
         }
     }
  }
}
