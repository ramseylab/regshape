<?xml version="1.0"?>
<?xml-stylesheet type="text/xml" href="../../config/documentation-stylesheet.xml"?>
<!DOCTYPE isbdocument [
  <!ENTITY % CommonConfig SYSTEM "../../config/CommonConfig.dtd">
  %CommonConfig;
  <!ENTITY docLastUpdated "2003/04/23">
   ]>

<isb:document xmlns:isb="http://www.systemsbiology.org/xmlns"
              xmlns:html="http://www.w3.org/TR/xhtml1"
              xmlns="http://www.w3.org/TR/xhtml1">

<isb:doctitle>Software Development Guidelines</isb:doctitle>
<isb:docdate>&docLastUpdated;</isb:docdate>
<isb:docversion>Version: 0.3, Date: &docLastUpdated;</isb:docversion>

<isb:doccontents />

<isb:docsection name="Introduction" label="introduction">

<p />
This document is a draft compilation of recommendations for
software development practices for the Bolouri group at the
Institute for Systems Biology.  None of the statements
contained herein should be construed as a &quot;hard-and-fast&quot;
rule.  Instead, the statements should be interpreted as guidelines
or recommendations for software development practices and quality
evaluation.  The purpose of these guidelines is primarily to help 
ensure that software tools <em>released</em> by the Bolouri group 
are of sufficient quality to reflect favorably on the group, and to 
(hopefully) win widespread acceptance in the relevant scientific
community.  Here, &quot;release&quot; can mean making the source 
code available locally, or to selected collaborators, or to the 
general public.
<p />
In this document, &quot;quality&quot; is taken to mean software
quality in the general sense, beyond just whether the software program
meets its functional specification.  It includes completeness and
sufficiency of the documentation, ease and straightforwardness of
installation, intuitiveness of the user interface, portability to
other operating systems and runtime environments, and the extent
to which the source code is amenable to extension and re-use.
<p />
This is meant to be an evolving document, reflecting contributions
and feedback from all members of the group.
<p />

</isb:docsection>


<isb:docsection name="Other Resources" label="otherresources">

This section describes a few textbooks that are useful for someone
who writes software, whether on a daily basis or just once in a while.
<p />
These references should be on <em>every</em> programmer's bookshelf:
<dl>
<dt><b>The Pragmatic Programmer</b>:</dt>
<dd>
It is strongly recommended that everyone in the group read the book
<em>The Pragmatic Programmer</em> by Andrew Hunt and David Thomas
(Addison-Wesley, 1999).  This book is very readable, and it
contains a wealth of practical advice on good programming practices.
<p /></dd>

<dt><b>The Practice of Programming</b>:</dt>
<dd>
Another excellent book on programming &quot;best practices&quot;
is <em>The Practice of Programming</em>, by Brian Kernighan (of 
the C programing language fame) and Rob Pike (Addison-Wesley, 1999).  
It has excellent examples that are translated into C++, Java, and other 
languages.
<p /></dd>
</dl>

<p />

Here are some additional resources that you may find useful:
<dl>

<dt><b>Design Patterns</b>:</dt>
<dd>A classic book on object-oriented software design
is <em>Design Patterns</em> by Gamma, Helm, Johnson and Vlissides
(Addison-Wesley, 1995).
<p /></dd>

<dt><b>Effective C++</b>:</dt>
<dd>
Scott Meyers' book on C++ programming techniques is a must-have for
any C++ programmer, <em>Effective C++</em> (Addison-Wesley, 1997).
The follow-up book <em>More Effective C++</em> (Addition-Wesley, 1995)
is also useful.
<p /></dd>

<dt><b>Open Source Development with CVS</b>:</dt>
<dd>A great overall reference for CVS, with emphasis on
open-source development:  <em>Open Source Development with CVS</em>,
by Karl Franz Fogel (out of print, look on Amazon for availability).<p /></dd>

</dl>
</isb:docsection>

<isb:docsection name="CVS Repository" label="cvsrepository">
Our group uses a <b>source code control system</b> in order to track changes
to software source files.  Our source code control system is CVS, which is
an open-source product based on the RCS revision control system.  

<isb:docsubsection name="Using CVS" label="cvsavailability">
CVS is available as a command-line utility &quot;<code>cvs</code>&quot; on nearly
all Unix-like operating systems, including most standard Linux distributions.
To confirm that CVS is installed correctly, you
should be able to execute the "<code>cvs</code>" command
from your command shell prompt.  This should be already installed on
your computer if you are using a modern Linux distribution.
<p />
There is also a graphical CVS client for the Linux operating system,
called &quot;Cervisia&quot;.  It should be installed by default on
a full installation of a standard desktop Linux distribution. 
To run it, just type &quot;cervisia&quot; at the command (shell) prompt.
The Cervisia program is open source, and is available at 
<a href="http://cervisia.sourceforge.net"><code>cervisia.sourceforge.net</code></a>.
<p />
To access CVS from a Windows computer, you will likely need to download and 
install a Windows CVS client.  There are many CVS clients available for 
Windows, in particular, <a href="http://www.tortoisecvs.org">TortoiseCVS</a>
has been recommended.  For more information on how to use the
Unix (command-line) CVS program, please refer to the 
<a href="&privateRepositoryURL;/CVSManual.pdf">CVS User Manual</a>. 
</isb:docsubsection>

<isb:docsubsection name="CVS Rules of the Road" label="cvsrules">
This section describes recommendations and local conventions for 
how the CVS repository should be used:
<dl>
<dt><b>file locking and pipes</b>:</dt>
<dd>
Please be advised that CVS has a file-locking mechanism built
into it, such that when a CVS operation is occurring for a
given file or directory, no one else may initiate a CVS operation
involving that file or directory.  Normally CVS operations complete
very rapidly so this is of minimal consequence.  However, if you 
(on a Unix-like computer) execute a command like this:
<blockquote>
<pre>
cvs log MyFile.cpp | more
</pre>
</blockquote>
please be aware that it will <em>lock</em> the file
<code>MyFile.cpp</code> until you terminate the 
&quot;<code>more</code>&quot; program.  So, please do not leave
CVS operations locked for long periods of time.  It is OK to use
&quot;more&quot; in the above fashion, provided that you do not
leave the file in a locked state for a long period of time.
<p />
</dd>

<dt><b>binary files</b>:</dt>
<dd>
<p>
Importing large binary files into a CVS project directory
is generally discouraged because it can make CVS operations involving 
that directory very slow.  Furthermore, the purpose of CVS is
to track and manage changes to <em>source</em> files.  Most
binary files are derivative in nature (e.g., compiled object files,
distilled PDF files, linked binary executables, etc.).  Files 
created directly by human editing are (almost) always textual.
In general, if you have a choice between importing a derivative
binary file into CVS or its textual source file, please consider
importing the source file.  If you have different types of source
file formats, try to use the &quot;most upstream&quot; source file
format, from which the subsequent source file format can be derived.
</p>
<p>
As an example, suppose you have a document
written in LaTeX, and the PDF distillation of the processed LaTeX
file. It would be preferable to check the (LaTeX) source file
into CVS rather than the (PDF) derivative binary file.
As a second example, you might have a Bison or Yacc file that
gets translated into a C++ source file.  It is preferable
to check the Bison/Yacc source file into CVS (rather than the 
C++ source file generated by Bison/Yacc), since the C++ source
file is totally derivable from the Bison file in this case.
</p>
<p>
A corollary to this is that it is discouraged to check compressed 
(e.g., gzipped) files into CVS, since this thwarts CVS's ability to
distinguish line-by-line changes in the file.  There are exceptions
to this rule, such as compressed image file formats (JPEG) and
StarOffice source files formats, which are actually compressed XML.
</p>
<p>
Many times a project
makefile produces a &quot;build file&quot; or &quot;tarball&quot;
that represents the distribution of the project.  It is discouraged
to check these build files or tarballs into CVS as well, for the
reasons described above.  These files should be archived and
versioned outside of CVS, for example, in a group software 
&quot;build archive&quot; adjacent to the group CVS archive.
It is OK to import small binary files that have no textual
&quot;source&quot; format, into CVS.  Examples include small 
PNG or JPEG image files taken from scanned images or clipart.
</p>
</dd>

<dt><b>external libraries and packages</b></dt>
<dd>
<p>
Almost all nontrivial software projects involve some number of 
external <b>dependencies</b>.  Here, &quot;external&quot; dependency
means a dependency on an external unit of software that is not under 
your direct control.  These dependencies usually take the form
of libraries or packages that are downloaded and against which
the project source files are compiled/linked.  As a general rule, it is
discouraged to check external libraries and packages into CVS with
your project.  This is in keeping with the philosophy that CVS
is for tracking our <em>own</em> software development, not someone
else&apos;s software development projects.  The larger and/or 
more standard a library, the more you are discouraged from checking 
the library into CVS.  An extreme example would something like 
<code>glibc</code>, <code>libstdc++</code>, or the Sun JDK.  Under 
no circumstances should you check into CVS either sources or 
binaries for large, standard libraries such as these.
</p>
<p>
If your software depends on an external library that is
readily available through standard software distribution
channels, and you do not intend to make any source code
modifications to the library, there is really no point in your
checking the source code for the library into CVS.  Instead,
you should keep the source code in a common location (such as
a network directory available to the group) so that it is 
backed up, the version number obvious, and available to other
developers within your development group.  You <em>should</em>
check a README or some other file into your software source
tree, indicating the exact version of the external library
that should be used to compile the software.  
</p>
<p>
If you intend to make substantial changes to the external library,
it makes sense to import the sources for the library (just the 
sources, not the binaries) into CVS.  This makes it possible
for local modifications to the sources can be tracked.  Make
sure you tag the source code for the external library with an
appropriate vendor/version tag, at the time that you import it.
Making substantial changes to an external library should be
considered a last resort; it is generally better to try and
participate in the development of the external library, so
that your changes can eventually get merged back into the
main line of development for that library.  To avoid painful
merge problems if/when major changes are made by the maintainers
of the external library, please keep the practice of locally
modifying external libraries to a minimum.  
</p>
<p>
If you do not intend to make changes to the source code for
the external library, and if you need to distribute the
external library with your application, consider modifying
your build system to auto-FTP the latest build of the library
from an approved source server for the builds of that library.
This technique should be fairly straightforward for Java libraries.
For C++, it may be a little more complicated because of the need to
get the source header files as well as the binary 
&quot;<code>.so</code>&quot; file for the library.  In that
case, you might be best served by installing an approved (tested) 
build of the external library in some group-accessible location,
such as on a group-readable network directory.  Again, it should
not be necessary to check the source code or binary for the library
into CVS, although it is definitely desirable to include a README
with your source code specifying the version number of the external
library dependency.  
</p>
</dd>

<dt><b>version number in directory names</b></dt>
<dd>
Creating directory names that contain version numbers is strongly
discouraged, within the context of a CVS archive.  For example,
if you want to create a project directory for a project &quot;Babar&quot;,
and first major version number of the Babar project is 1.0, please do
not create a CVS project directory
<blockquote>
<code>
CVSARCHIVE/babar-1.0
</code>
</blockquote>
or the like.  This scheme would require moving the sources to a 
new directory when work commences on the next major release; this
is something best handled through the branching facility provided
by CVS.  In the case of the Babar project, it is better to create
a project directory such as this:
<blockquote>
<code>
CVSARCHIVE/babar
</code>
</blockquote>
You may use the &quot;cvs tag&quot; feature to designate the
snapshot of source files for the 1.0 release of the project.
CVS has a fairly rich tagging feature that is designed to annotate
version numbers for source trees.
<p /></dd>

<dt><b>tabs vs. spaces in source files</b></dt>
<dd>
There is no hard-and-fast standard on this issue, but please be
mindful of the distinction between &quot;hard tabs&quot; and
normal whitespace (space characters).  Many editors embed
the &quot;tab&quot; character into a source file when you hit
the &quot;tab&quot; key in order to indent your source code.
Most editors can be configured to indent the code using spaces
instead; this way, when you hit the &quot;tab&quot; key,
the editor indents just as it always did, but it does so by
inserting the appropriate number of spaces into your source
file.  This will be appreciated by the next developer who 
may be working with your source file using a different editor, 
that will likely have different &quot;tab stops&quot;. Configuring
your editor to avoid inserting tab characters into the source
file (and instead insert space characters) will ensure consistent
indentation and avoid formatting problems when your source file
is opened in a different editor than the one you used to create
the file, and is considered to be a sound multi-developer 
programming practice.
<p /></dd>

<dt><b>release tagging conventions</b></dt>
<dd>
Before you release a new version of your software, please tag
the snapshot of source files corresponding to this release,
in the CVS archive.  This ensures that the build for this 
release will always be &quot;reproducible&quot;.  If the build
is somehow lost or destroyed, or needs to be validated, you 
can just export the source snapshot corresponding to your release
tag, and build from the source snapshot (even if there have been
changes to the trunk of the CVS repository since your last
release).  Here is an illustration of the process for the
case of the &quot;Babar&quot; example project described above.
When you have committed all your source changes that you want
to go into the 1.0 release of &quot;Babar&quot;, issue the
following command in your CVS enlistment (working directory):
<blockquote>
<pre>
cvs tag -F BABAR-1_0
</pre>
</blockquote>
Note that the period character has been changed to an underscore.
This is due to a peculiarity in the CVS program, namely, that 
CVS does not permit periods in &quot;tag&quot; names.  The tag
name specified above is &quot;<code>BABAR-1_0</code>&quot;.
This command recursively tags all the source code under your
working directory.  
<blockquote>
<b>WARNING:</b> if your CVS working
directory is the entire group CVS archive, do not issue this
command in the top-level CVS directory, or you will be tagging sources for
other projects (other than the Babar project).  Instead, you  would
issue this command in the &quot;<code>babar</code>&quot; subdirectory.
</blockquote>
You may opt to use a different nomenclature for your release tags
than the one suggested above.  Please try to maintain consistency 
from version to version, in your choice of release version tag
nomenclature.  For example, if you use &quot;REL-1_0&quot; in 
version 1.0, please use &quot;REL-1_1&quot; in version 1.1.
<p /></dd>

<dt><b>file naming conventions:</b></dt>
<dd>
At this time, there are no hard-and-fast naming conventions for files.
However, you are encouraged to use &quot;standard&quot; file naming
conventions where possible.  This will help others (and the compiler
or software developtment tools they are using) to understand the file
types you have imported into CVS.  This means that your file extensions
should generally be lower-case (i.e., use &quot;<code>.c</code>&quot; 
rather than &quot;<code>.C</code>&quot;).  Furthermore, your file 
extensions should be <em>consistent within your project</em>.  It is no
longer necessary to restrict file extensions to three characters.  For
example, &quot;.html&quot; is an acceptable extension (and preferred
over the Windows-centric &quot;.htm&quot; extension).  Please try to
refrain from using spaces or non-alphanumeric characters in your
file names, except for hyphens and underscores.  The period should only
be used to separate the filename from the extension.  Please use
&quot;.txt&quot; to designate ASCII text files, which helps enable
people viewing the file using a GUI-type file browser.  In general, most
files should have extensions indicating their file type.  Exceptions to
this are &quot;makefiles&quot;, which usually have the special name 
&quot;Makefile&quot; (with no extension).  The following are &quot;good&quot; filenames:
<blockquote>
<pre>
Babar.cc
Babar.hh
Babar.java
README.txt
Makefile
Babar-UserGuide.html
Babar_UserGuide.html
</pre>
</blockquote>
The following are examples of poor filename choices:
<blockquote>
<pre>
Babar.CPP
'Babar Main.cc'
Foo$Bar.cc
</pre>
</blockquote>
Above all else, consistency of file nomenclature within your project
is the most important principle to observe.
<p /></dd>

<dt><b>RCS keywords</b>:</dt>
<dd>
RCS keywords (see the CVS manual for an explanation of their purpose)
can be useful for embedding version information of a source file,
into the source file.  However, the use of the specific RCS keyword 
&quot;$Log$&quot;
is strongly discouraged.  It tends (over time) to
horribly clutter up the source file, and is merely a repetition of
information that is available in the CVS commit logs.  Please note
that RCS keywords should be used with care, as they can cause merge
conflicts when merging source files (e.g., from a branch into the main
development trunk).  Ideally, RCS keywords will be used sparingly and
with a clear purpose as to why they are needed (rather than indiscriminatly
using them in every source file's header comment).
<p /></dd>

<dt><b>atomicity of check-ins</b>:</dt>
<dd>
After the initial import of the source code for your project into
CVS, it is recommended that future check-ins (or &quot;commits&quot;)
into the repository be as <em>atomic</em> as possible.  This means
striving to commit the changes for a specific feature request or bug
fix, rather than commiting changes for multiple features and
bug fixes at the same time.  There are many cases where this is not
practical or advisable.  However, in general it is a good practice
to keep your changes as atomic as possible.  This helps others who
are tracking/using your project's source code to determine <em>which</em>
change may have broken something for them.  Furthermore, it will make
it easy for future maintainers of your software to understand the
past development history of the project.
<p /></dd>

<dt><b>keeping documentation in CVS</b>:</dt>
<dd>
It is strongly recommended that you import your documentation
source files (i.e., &quot;.tex&quot; files or &quot;.html&quot;
files) into CVS, alongside the source code for your project.  The
source code is in many cases all but useless without the documentation,
and the documentation can and should be versioned as it evolves. 
Documentation that is essentially derivative (e.g., javadoc HTML
that is extracted from the source code) need not be imported
into CVS, since the information contained in the documentation
is already contained (in source comment form) in the source files.
<p /></dd>

<dt><b>branching vs development in the trunk</b>:</dt>
<dd>
This issue is still under discussion.  Branching is a very powerful
feature of CVS for enabling major forward-looking development work on 
a project while not disturbing ongoing maintenance work (i.e., small bug 
fixes and feature improvements) on the previous release of the project.
However, branching can be tricky and requires a good understanding
of CVS.  It is recommended that users who are new to CVS do their
development work on the &quot;main trunk&quot; (this is the default),
until such time branching is really needed.
<p /></dd>

<dt><b>DOS/Unix linefeed issue</b>:</dt>
<dd>
Please be advised that there is a vexing, long-standing
incompatibility for ASCII (text) files between DOS/Windows systems
and Unix-type operating systems.  The problem stems from the fact that
text files on DOS/Windows systems include an extra linefeed character
at the end of each line in addition to the carriage-return character.
In contrast, Unix-type operating systems just use a single carriage-return
character to designate the end of the line.  For maximum compatibility
with Unix text editors, it is recommended that you try to strip out
linefeed characters from text files, before importing your files into
CVS.  Most editors should have the capability of doing this.  Note that
this is not a requirement of CVS, just a good practice for projects that
have shared development between Windows and Unix systems.
<p /></dd>

<dt><b>makefiles and build tools:</b></dt>
<dd>
Most software projects eventually grow to the point where some
scripts or makefile-type tools are used for the &quot;build&quot;
and/or installation proces.  These files should be checked into
CVS, in their most basic source format.  For example, if you have
a plain make &quot;Makefile&quot; for your project, it should be
checked into CVS alongside your source code.  On the other hand,
if you are using GNU autoconf/configure, then you would want to
instead import your <code>Makefile.in</code> into CVS, since in this
case your <code>Makefile</code> is derivative (it is generated by 
<code>configure</code>).  Similarly, other scripts used for building
and testing your project, should be imported into CVS so they can
be properly versioned.
<p /></dd>

<dt><b>meddling with the CVS archive:</b></dt>
<dd>
A CVS setup consists of a central <b>archive (repository)</b> and people's
working directories (<b>enlistments</b>).  The central archive is
(almost) never manually modified in any way; it is (almost) always
modified using the various CVS commands.  As a general rule, only the
CVS archive maintainer should touch the CVS archive directly. 
Deleting directories or files out of the archive can cause problems
for users, ranging in severity from annoying to catastrophic.  Please
only interact with CVS through the CVS commands, and not through 
direct manipulation of the archive files.  
<p /></dd>

<dt><b>renaming a directory in CVS:</b></dt>
<dd>
If you wish to rename a directory, the easiest thing is to
create the new directory, and add it to your enlistment 
using &quot;<code>cvs add &lt;dirname&gt;</code>&quot;.
Then copy the source files to the new directory, and add them
using &quot;<code>cvs add &lt;filename&gt;</code>&quot;.
Finally, remove the files from the old directory and 
issue the &quot;<code>cvs remove &lt;filename&gt;</code>&quot;
command, in order to mark them (in the archive) as removed.
In so doing, you will lose the version history of the source files,
but you have avoided the need to manipulate the CVS repository/archive
directly.  If you <em>absolutely must</em> keep the version history
for your files, please contact the CVS archive maintainer to have
the directory moved.  Note that when using the above technique, there
is no need to &quot;remove&quot; the old file.  If you run 
&quot;<code>cvs update</code>&quot; with the &quot;-P&quot; option,
the empty old directory will automatically be removed from your
enlistment, by the CVS program.  In fact, if you attempt to remove
the old directory yourself (from your enlistment), it can cause
problems.  
<p /></dd>

</dl>
</isb:docsubsection>
</isb:docsection>

<isb:docsection name="Documentation Standards" label="docstandards">

This section describes some suggestions for minimum standards for
documentation, for a software project to be considered of sufficient 
quality to be &quot;released&quot;.   Note that the file names mentioned below
are not to be followed literally; it is the content that is important.
<p />

<dl>
<dt><a name="packagedocs" /><b>package documentation</b>:</dt>
<dd>
Each package or library subdirectory within your project source tree
should contain a summary file (e.g., <code>README</code> or 
<code>package.html</code> file) that describes the purpose and
function of the package or library contained in that subdirectory.
An example is the <a href="../ISBJava/javadoc/isb/chem/package-summary.html">
package summary for the <code>isb.chem</code> Java package</a>.
<p />
</dd>

<dt><a name="headercomments" /><b>source file header comments</b>:</dt>
<dd>
Each source file should have a header comment that provides the
following information:
<ul>
<li>the purpose of the file, i.e., what function it provides for
the project or the application</li>
<li>the original author or authors who implemented the file
(later maintainers do not get to put their names on the file, 
unless they significantly overhaul the implementation)
</li>
<li>the license terms (e.g., GPL).  It is not clear whether the
full text of the license needs to be included.  At the minimum,
a pointer to a file containing the text of the license (which 
should be in the CVS repository for the project) should be included. 
</li>
</ul>
It is helpful if these header comments are in some structured
format that can be extracted by a documentation-generating system,
in order to provide developers (or users of your library/package)
with API-level documentation of your classes and/or modules.  
Examples include Javadoc (for java classes), doc++ (for C++ classes),
POD (for Perl modules), etc.
An example of API documentation extracted from source file header
comments is the <a href="../ISBJava/javadoc">ISBJava API documentation</a>.
<p />
It may be useful to include a copyright and license notification
in a header comment at the top of each source file of your 
project.  An example is shown here:
<blockquote>
<pre>
/*
 * Copyright (C) 2003 by Institute for Systems Biology,
 * Seattle, Washington, USA.  All rights reserved.
 * 
 * This source code is distributed under the GNU Lesser 
 * General Public License, the text of which is available at:
 *   http://www.gnu.org/copyleft/lesser.html
 */
</pre>
</blockquote>
The comment makes specific reference to the license
under which the software is distributed.
<p />
</dd>

<dt><b>Release Notes or README file</b>:</dt>
<dd>
The project&apos;s deliverable should be distributed 
with an overall <code>README</code>-type
file that explains what the project is, provides a roadmap of the
documentation, gives the version number and date of the release,
and gives contact information for contacting the authors.  This
document can include a set of release notes, or reference
the project home page where this information can be accessed.
This document should be distributed with your application.
An example of a release notes document is the
<a href="../Dizzy/docs/ReadMe.html">Dizzy ReadMe</a>
document.  
<p /></dd>

<dt><b>INSTALL.txt file</b>:</dt>
<dd>
For projects that do not have a point-and-click installation
mechanism like <a href="#buildinginstallers">InstallAnywhere</a>
or Java Web Start, installation will usually be a non-trivial
step for users to overcome.  For such projects, it is appropriate
to provide users with some kind of <code>INSTALL.txt</code>-type
file that explains how to (if applicable, build and) install
the software and set it up so that a given user can run it.  This
should include a disclaimer about the specific operating system
and build/runtime environment in which the author/developer tested
the software.  For a Java package, you would want to indicate the
specific JDK (vendor and version number) you used, as well as
the host operating system type and version, as well as any runtime
flags or other information passed to the JVM.  For a C++ program,
even more detail about the host operating system (including the
kernel version number and compiler/linker vendor and version number) 
might be appropriate to include.  The level of detail should be sufficient
that a determined and reasonably sophisticated user can successfully
replicate the process that the author used to install and configure
the software on his/her development machine.
The document should include, or provide links to a home page
containing, a summary of all external package/library dependencies.
<p /></dd>

<dt><b>Project Home Page</b>:</dt>
<dd>
For many projects, it is appropriate to create a Home Page
that is the springboard for accessing documentation, installation
kits, and source code for the project&apos;s source code.
An example of such a document is the
<a href="../Dizzy/">Dizzy Home Page</a>.
<p />
</dd>

<dt><b>Version History</b>:</dt>
<dd>
After a project reaches a certain point in its life cycle,
it may be appropriate to dedicate a separate document or
web page to chronicling the version history of the project.
This page should list each release of the project&apos;s 
deliverable, with a date, version number, and a short description
of the features of each release.  An example of such a
document is the 
<a href="../Dizzy/docs/VersionHistory.html">Dizzy Version History</a>.
<p />
</dd>

<dt><b>user guide or tutorial</b>:</dt>
<dd>
For most projects, it will be appropriate and useful to include
a user guide or tutorial.  The idea is to have a document 
(referenced in the main <code>README.txt</code> file) that 
explains how to actually use the software once it has been
installed.  Ideally this would include sample use scenarios
(with screen shots, in the case of a GUI application), or
sample code (in the case of a library or package).  In general, 
the level of detail that is appropriate for this document depends 
on the size (complexity) and level of maturity (stage in its 
life-cycle) of the software project.  An example of a user manual
written for locally developed software is the
<a href="../Dizzy/docs/UserManual.html">Dizzy User Manual</a>.
<p /></dd>

<dt><b>coding standards</b>:</dt>
<dd>
This is a whole subject unto itself.  Please see the 
<a href="#coding standards">&quot;coding standards&quot;</a>
section below, for more information.
<p /></dd>
</dl>

</isb:docsection>

<isb:docsection name="Coding Standards" label="codingstandards">

<p>
For starters, it is recommended that you read the books in the
<a href="#otherresources">software development resources</a> section
above.  In particular, the <em>Pragmatic Programmer</em> book has
many important tips on good coding style and practices.  In this
document, we will only attempt to highlight a few basic points
regarding coding style and practices.
</p>
<p>

<dl>
<dt><b>variable names:</b></dt>
<dd>
Variable names should be descriptive of their meaning.  It is
strongly discouraged to use variable names that convey nothing 
about how they are used, such as &quot;A&quot; or &quot;B&quot;.
Instead, variable names should convey how the variable is used,
such as &quot;<code>simulation_start_time_seconds</code>&quot;.  
Note that including units in the variable name, for numeric
data types, is often helpful to others who are reading your code.
<p /></dd>

<dt><b>method/function header comments:</b></dt>
<dd>
In addition to the class/module header comments described 
<a href="#headercomments">above</a>, it is helpful if the public
methods in a class (or external functions in a C module) have 
header comments that explain their functional purpose and 
the nature of their arguments and return value.  It is even
better if exceptional conditions can be documented (i.e.,
exceptions thrown or error codes returned).
<p /></dd>

<dt><b>method/function names:</b></dt>
<dd>
Method or function names should be description of what the 
method or function does.  If a method is so long and complex that
its purpose/function is not completely clear from the method name, 
class context, and a short header comment, it is probably advisable
to break up (&quot;refactor&quot;) the method into sub-methods
or sub-functions.
<p /></dd>

<dt><b>generic naming:</b></dt>
<dd>
<p>
Try to avoid the use of jargon or acronyms in the naming
of classes, methods, and class fields, to that extent that it
does not significantly impede comprehension.  Acronyms, if needed,
should generally be spelled out, and possibly shortened if some
of the information conveyed by the acronym is obvious from context.
Try to avoid making specific references to organizational or
project names, which are by nature very transient.  This will help
to avoid needless code churn when a project name changes (which
is typically a frequent occurrence), or an institutional
affiliation changes.  An exception to this is in the package 
naming scheme in Java, in which the starting element of the
package name is often used to convey the organizational 
affiliation of the maintainer/author of the package.  
</p>
</dd>

<dt><b>use of namespaces:</b></dt>
<dd>
<p>
In Java, you should try to
leverage the package namespace construct to convey important 
contextual information about your classes.  For example, if 
your package namespace is <code>isb.chem</code>, there is
no need to name a class within that package <code>ChemSpecies</code>,
because the &quot;chem&quot; is obvious from the package context.
It would be better to name the class <code>Species</code>.
However, you should try to avoid the reuse of common class names 
that are alwready a part of the standard Java API.  For example, 
class names like <code>Iterator</code> and <code>File</code> should
be avoided, because it just causes confusion when people familiar
with the Java language try to read your code.  It is better to
group package names by function rather than by project or
organizational group.  For example, a package name
<code>isb.chem.scripting</code> would be far better than
the package name <code>isb.chem.dizzy</code>.  In five years,
the &quot;<code>dizzy</code>&quot; moniker may convey no meaning
to future readers of the code, but it is a certainty that
&quot;<code>scripting</code>&quot; will convey some meaning.
It is acknowledged that striving for generic, functionally descriptive
package names can be a bit confusing at first, when people ask, 
&quot;but where is the code for the Dizzy project?&quot;.  
However, over the long haul, it can help avoid a lot of needless 
code churn, as projects change and code is re-used for different
purposes.
</p>
<p>
In C++, namespaces are becoming more standard and are supported by
most modern compilers.  However, nesting of namespaces in C++ does
not appear to be very widespread, in contrast to the package namespaces
in Java.  If you do define your own C++ namespace, make sure that
you pick a namespace that conveys something useful about the 
classes aggregated under the namespace.  For example, a good namespace
would be something like <code>Math</code> or <code>DB</code>.
It is generally a bad idea to use a project name as the namespace,
because project names tend to change frequently and to lose their
meaning over time, whereas a namespace like <code>Math</code>
will always be meaningful, no matter what happens to your project
or institutional affiliation.  A good compromise might be to 
use a nested namespace such as <code>ISB::Math</code> or
<code>ISBMath</code>, but again, make sure that institutional
prefix is not going to change, before using it all over your 
code base.
</p>
</dd>

</dl>
</p>

</isb:docsection>

<isb:docsection name="Building Installers" label="buildinginstallers">
<p>
The &mainGroup; has purchased a single-developer license of the
InstallAnywhere software product from ZeroG Software.  This product
enables the creation of an executable &quot;installer&quot; file
for a software application.  This installer program installs the
software application and creates the necessary links to the application.
It also can optionally provide a version of the Java Runtime Environment
(JRE), for target platforms that do not already have a suitable
Java Runtime Environment installed.  
</p>
<p>
The InstallAnywhere product is currently installed on the Linux host
<blockquote>
<pre>
hamid-lx.systemsbiology.net
</pre>
</blockquote>
To run InstallAnywhere remotely, you will need access to
a desktop computer with an X-windows server and OpenSSH 
installed. Any desktop Linux computer will suffice.  From your 
desktop computer, simply do the following:
<blockquote>
<pre>
ssh -X -C hamid-lx.systemsbiology.net
/local/InstallAnywhere_6_Standard/InstallAnywhere
</pre>
</blockquote>
This should run the InstallAnywhere program remotely, in a window
on your desktop computer.  For instructions on how to use the
InstallAnywhere program, please refer to the
<a href="&privateRepositoryURL;/InstallAnywhere5_UserManual.pdf">InstallAnywhere
User Manual</a>.
</p>

</isb:docsection>

</isb:document>




